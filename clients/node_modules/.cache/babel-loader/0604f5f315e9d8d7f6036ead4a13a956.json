{"ast":null,"code":"import matches from 'dom-helpers/matches';\nimport qsa from 'dom-helpers/querySelectorAll';\nimport addEventListener from 'dom-helpers/addEventListener';\nimport React, { useCallback, useRef, useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { useUncontrolledProp } from 'uncontrollable';\nimport usePrevious from '@restart/hooks/usePrevious';\nimport useForceUpdate from '@restart/hooks/useForceUpdate';\nimport useGlobalListener from '@restart/hooks/useGlobalListener';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport DropdownContext from './DropdownContext';\nimport DropdownMenu from './DropdownMenu';\nimport DropdownToggle from './DropdownToggle';\nvar propTypes = {\n  /**\n   * A render prop that returns the root dropdown element. The `props`\n   * argument should spread through to an element containing _both_ the\n   * menu and toggle in order to handle keyboard events for focus management.\n   *\n   * @type {Function ({\n   *   props: {\n   *     onKeyDown: (SyntheticEvent) => void,\n   *   },\n   * }) => React.Element}\n   */\n  children: PropTypes.node,\n\n  /**\n   * Determines the direction and location of the Menu in relation to it's Toggle.\n   */\n  drop: PropTypes.oneOf(['up', 'left', 'right', 'down']),\n\n  /**\n   * Controls the focus behavior for when the Dropdown is opened. Set to\n   * `true` to always focus the first menu item, `keyboard` to focus only when\n   * navigating via the keyboard, or `false` to disable completely\n   *\n   * The Default behavior is `false` **unless** the Menu has a `role=\"menu\"`\n   * where it will default to `keyboard` to match the recommended [ARIA Authoring practices](https://www.w3.org/TR/wai-aria-practices-1.1/#menubutton).\n   */\n  focusFirstItemOnShow: PropTypes.oneOf([false, true, 'keyboard']),\n\n  /**\n   * A css slector string that will return __focusable__ menu items.\n   * Selectors should be relative to the menu component:\n   * e.g. ` > li:not('.disabled')`\n   */\n  itemSelector: PropTypes.string,\n\n  /**\n   * Align the menu to the 'end' side of the placement side of the Dropdown toggle. The default placement is `top-start` or `bottom-start`.\n   */\n  alignEnd: PropTypes.bool,\n\n  /**\n   * Whether or not the Dropdown is visible.\n   *\n   * @controllable onToggle\n   */\n  show: PropTypes.bool,\n\n  /**\n   * Sets the initial show position of the Dropdown.\n   */\n  defaultShow: PropTypes.bool,\n\n  /**\n   * A callback fired when the Dropdown wishes to change visibility. Called with the requested\n   * `show` value, the DOM event, and the source that fired it: `'click'`,`'keydown'`,`'rootClose'`, or `'select'`.\n   *\n   * ```ts static\n   * function(\n   *   isOpen: boolean,\n   *   event: SyntheticEvent,\n   * ): void\n   * ```\n   *\n   * @controllable show\n   */\n  onToggle: PropTypes.func\n};\n\nfunction useRefWithUpdate() {\n  var forceUpdate = useForceUpdate();\n  var ref = useRef(null);\n  var attachRef = useCallback(function (element) {\n    ref.current = element; // ensure that a menu set triggers an update for consumers\n\n    forceUpdate();\n  }, [forceUpdate]);\n  return [ref, attachRef];\n}\n/**\n * @displayName Dropdown\n * @public\n */\n\n\nfunction Dropdown(_ref) {\n  var drop = _ref.drop,\n      alignEnd = _ref.alignEnd,\n      defaultShow = _ref.defaultShow,\n      rawShow = _ref.show,\n      rawOnToggle = _ref.onToggle,\n      _ref$itemSelector = _ref.itemSelector,\n      itemSelector = _ref$itemSelector === void 0 ? '* > *' : _ref$itemSelector,\n      focusFirstItemOnShow = _ref.focusFirstItemOnShow,\n      children = _ref.children;\n\n  var _useUncontrolledProp = useUncontrolledProp(rawShow, defaultShow, rawOnToggle),\n      show = _useUncontrolledProp[0],\n      onToggle = _useUncontrolledProp[1]; // We use normal refs instead of useCallbackRef in order to populate the\n  // the value as quickly as possible, otherwise the effect to focus the element\n  // may run before the state value is set\n\n\n  var _useRefWithUpdate = useRefWithUpdate(),\n      menuRef = _useRefWithUpdate[0],\n      setMenu = _useRefWithUpdate[1];\n\n  var menuElement = menuRef.current;\n\n  var _useRefWithUpdate2 = useRefWithUpdate(),\n      toggleRef = _useRefWithUpdate2[0],\n      setToggle = _useRefWithUpdate2[1];\n\n  var toggleElement = toggleRef.current;\n  var lastShow = usePrevious(show);\n  var lastSourceEvent = useRef(null);\n  var focusInDropdown = useRef(false);\n  var toggle = useCallback(function (nextShow, event) {\n    onToggle(nextShow, event);\n  }, [onToggle]);\n  var context = useMemo(function () {\n    return {\n      toggle: toggle,\n      drop: drop,\n      show: show,\n      alignEnd: alignEnd,\n      menuElement: menuElement,\n      toggleElement: toggleElement,\n      setMenu: setMenu,\n      setToggle: setToggle\n    };\n  }, [toggle, drop, show, alignEnd, menuElement, toggleElement, setMenu, setToggle]);\n\n  if (menuElement && lastShow && !show) {\n    focusInDropdown.current = menuElement.contains(document.activeElement);\n  }\n\n  var focusToggle = useEventCallback(function () {\n    if (toggleElement && toggleElement.focus) {\n      toggleElement.focus();\n    }\n  });\n  var maybeFocusFirst = useEventCallback(function () {\n    var type = lastSourceEvent.current;\n    var focusType = focusFirstItemOnShow;\n\n    if (focusType == null) {\n      focusType = menuRef.current && matches(menuRef.current, '[role=menu]') ? 'keyboard' : false;\n    }\n\n    if (focusType === false || focusType === 'keyboard' && !/^key.+$/.test(type)) {\n      return;\n    }\n\n    var first = qsa(menuRef.current, itemSelector)[0];\n    if (first && first.focus) first.focus();\n  });\n  useEffect(function () {\n    if (show) maybeFocusFirst();else if (focusInDropdown.current) {\n      focusInDropdown.current = false;\n      focusToggle();\n    } // only `show` should be changing\n  }, [show, focusInDropdown, focusToggle, maybeFocusFirst]);\n  useEffect(function () {\n    lastSourceEvent.current = null;\n  });\n\n  var getNextFocusedChild = function getNextFocusedChild(current, offset) {\n    if (!menuRef.current) return null;\n    var items = qsa(menuRef.current, itemSelector);\n    var index = items.indexOf(current) + offset;\n    index = Math.max(0, Math.min(index, items.length));\n    return items[index];\n  };\n\n  useGlobalListener('keydown', function (event) {\n    var _menuRef$current, _toggleRef$current;\n\n    var key = event.key;\n    var target = event.target;\n    var fromMenu = (_menuRef$current = menuRef.current) == null ? void 0 : _menuRef$current.contains(target);\n    var fromToggle = (_toggleRef$current = toggleRef.current) == null ? void 0 : _toggleRef$current.contains(target); // Second only to https://github.com/twbs/bootstrap/blob/8cfbf6933b8a0146ac3fbc369f19e520bd1ebdac/js/src/dropdown.js#L400\n    // in inscrutability\n\n    var isInput = /input|textarea/i.test(target.tagName);\n\n    if (isInput && (key === ' ' || key !== 'Escape' && fromMenu)) {\n      return;\n    }\n\n    if (!fromMenu && !fromToggle) {\n      return;\n    }\n\n    if (!menuRef.current && key === 'Tab') {\n      return;\n    }\n\n    lastSourceEvent.current = event.type;\n\n    switch (key) {\n      case 'ArrowUp':\n        {\n          var next = getNextFocusedChild(target, -1);\n          if (next && next.focus) next.focus();\n          event.preventDefault();\n          return;\n        }\n\n      case 'ArrowDown':\n        event.preventDefault();\n\n        if (!show) {\n          onToggle(true, event);\n        } else {\n          var _next = getNextFocusedChild(target, 1);\n\n          if (_next && _next.focus) _next.focus();\n        }\n\n        return;\n\n      case 'Tab':\n        // on keydown the target is the element being tabbed FROM, we need that\n        // to know if this event is relevant to this dropdown (e.g. in this menu).\n        // On `keyup` the target is the element being tagged TO which we use to check\n        // if focus has left the menu\n        addEventListener(document, 'keyup', function (e) {\n          var _menuRef$current2;\n\n          if (e.key === 'Tab' && !e.target || !((_menuRef$current2 = menuRef.current) != null && _menuRef$current2.contains(e.target))) {\n            onToggle(false, event);\n          }\n        }, {\n          once: true\n        });\n        break;\n\n      case 'Escape':\n        event.preventDefault();\n        event.stopPropagation();\n        onToggle(false, event);\n        break;\n\n      default:\n    }\n  });\n  return /*#__PURE__*/React.createElement(DropdownContext.Provider, {\n    value: context\n  }, children);\n}\n\nDropdown.displayName = 'ReactOverlaysDropdown';\nDropdown.propTypes = propTypes;\nDropdown.Menu = DropdownMenu;\nDropdown.Toggle = DropdownToggle;\nexport default Dropdown;","map":{"version":3,"names":["matches","qsa","addEventListener","React","useCallback","useRef","useEffect","useMemo","PropTypes","useUncontrolledProp","usePrevious","useForceUpdate","useGlobalListener","useEventCallback","DropdownContext","DropdownMenu","DropdownToggle","propTypes","children","node","drop","oneOf","focusFirstItemOnShow","itemSelector","string","alignEnd","bool","show","defaultShow","onToggle","func","useRefWithUpdate","forceUpdate","ref","attachRef","element","current","Dropdown","_ref","rawShow","rawOnToggle","_ref$itemSelector","_useUncontrolledProp","_useRefWithUpdate","menuRef","setMenu","menuElement","_useRefWithUpdate2","toggleRef","setToggle","toggleElement","lastShow","lastSourceEvent","focusInDropdown","toggle","nextShow","event","context","contains","document","activeElement","focusToggle","focus","maybeFocusFirst","type","focusType","test","first","getNextFocusedChild","offset","items","index","indexOf","Math","max","min","length","_menuRef$current","_toggleRef$current","key","target","fromMenu","fromToggle","isInput","tagName","next","preventDefault","_next","e","_menuRef$current2","once","stopPropagation","createElement","Provider","value","displayName","Menu","Toggle"],"sources":["/home/firemort/Рабочий стол/Fullstack/CHRONOS/CHRONOS/clients/node_modules/react-overlays/esm/Dropdown.js"],"sourcesContent":["import matches from 'dom-helpers/matches';\nimport qsa from 'dom-helpers/querySelectorAll';\nimport addEventListener from 'dom-helpers/addEventListener';\nimport React, { useCallback, useRef, useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { useUncontrolledProp } from 'uncontrollable';\nimport usePrevious from '@restart/hooks/usePrevious';\nimport useForceUpdate from '@restart/hooks/useForceUpdate';\nimport useGlobalListener from '@restart/hooks/useGlobalListener';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport DropdownContext from './DropdownContext';\nimport DropdownMenu from './DropdownMenu';\nimport DropdownToggle from './DropdownToggle';\nvar propTypes = {\n  /**\n   * A render prop that returns the root dropdown element. The `props`\n   * argument should spread through to an element containing _both_ the\n   * menu and toggle in order to handle keyboard events for focus management.\n   *\n   * @type {Function ({\n   *   props: {\n   *     onKeyDown: (SyntheticEvent) => void,\n   *   },\n   * }) => React.Element}\n   */\n  children: PropTypes.node,\n\n  /**\n   * Determines the direction and location of the Menu in relation to it's Toggle.\n   */\n  drop: PropTypes.oneOf(['up', 'left', 'right', 'down']),\n\n  /**\n   * Controls the focus behavior for when the Dropdown is opened. Set to\n   * `true` to always focus the first menu item, `keyboard` to focus only when\n   * navigating via the keyboard, or `false` to disable completely\n   *\n   * The Default behavior is `false` **unless** the Menu has a `role=\"menu\"`\n   * where it will default to `keyboard` to match the recommended [ARIA Authoring practices](https://www.w3.org/TR/wai-aria-practices-1.1/#menubutton).\n   */\n  focusFirstItemOnShow: PropTypes.oneOf([false, true, 'keyboard']),\n\n  /**\n   * A css slector string that will return __focusable__ menu items.\n   * Selectors should be relative to the menu component:\n   * e.g. ` > li:not('.disabled')`\n   */\n  itemSelector: PropTypes.string,\n\n  /**\n   * Align the menu to the 'end' side of the placement side of the Dropdown toggle. The default placement is `top-start` or `bottom-start`.\n   */\n  alignEnd: PropTypes.bool,\n\n  /**\n   * Whether or not the Dropdown is visible.\n   *\n   * @controllable onToggle\n   */\n  show: PropTypes.bool,\n\n  /**\n   * Sets the initial show position of the Dropdown.\n   */\n  defaultShow: PropTypes.bool,\n\n  /**\n   * A callback fired when the Dropdown wishes to change visibility. Called with the requested\n   * `show` value, the DOM event, and the source that fired it: `'click'`,`'keydown'`,`'rootClose'`, or `'select'`.\n   *\n   * ```ts static\n   * function(\n   *   isOpen: boolean,\n   *   event: SyntheticEvent,\n   * ): void\n   * ```\n   *\n   * @controllable show\n   */\n  onToggle: PropTypes.func\n};\n\nfunction useRefWithUpdate() {\n  var forceUpdate = useForceUpdate();\n  var ref = useRef(null);\n  var attachRef = useCallback(function (element) {\n    ref.current = element; // ensure that a menu set triggers an update for consumers\n\n    forceUpdate();\n  }, [forceUpdate]);\n  return [ref, attachRef];\n}\n/**\n * @displayName Dropdown\n * @public\n */\n\n\nfunction Dropdown(_ref) {\n  var drop = _ref.drop,\n      alignEnd = _ref.alignEnd,\n      defaultShow = _ref.defaultShow,\n      rawShow = _ref.show,\n      rawOnToggle = _ref.onToggle,\n      _ref$itemSelector = _ref.itemSelector,\n      itemSelector = _ref$itemSelector === void 0 ? '* > *' : _ref$itemSelector,\n      focusFirstItemOnShow = _ref.focusFirstItemOnShow,\n      children = _ref.children;\n\n  var _useUncontrolledProp = useUncontrolledProp(rawShow, defaultShow, rawOnToggle),\n      show = _useUncontrolledProp[0],\n      onToggle = _useUncontrolledProp[1]; // We use normal refs instead of useCallbackRef in order to populate the\n  // the value as quickly as possible, otherwise the effect to focus the element\n  // may run before the state value is set\n\n\n  var _useRefWithUpdate = useRefWithUpdate(),\n      menuRef = _useRefWithUpdate[0],\n      setMenu = _useRefWithUpdate[1];\n\n  var menuElement = menuRef.current;\n\n  var _useRefWithUpdate2 = useRefWithUpdate(),\n      toggleRef = _useRefWithUpdate2[0],\n      setToggle = _useRefWithUpdate2[1];\n\n  var toggleElement = toggleRef.current;\n  var lastShow = usePrevious(show);\n  var lastSourceEvent = useRef(null);\n  var focusInDropdown = useRef(false);\n  var toggle = useCallback(function (nextShow, event) {\n    onToggle(nextShow, event);\n  }, [onToggle]);\n  var context = useMemo(function () {\n    return {\n      toggle: toggle,\n      drop: drop,\n      show: show,\n      alignEnd: alignEnd,\n      menuElement: menuElement,\n      toggleElement: toggleElement,\n      setMenu: setMenu,\n      setToggle: setToggle\n    };\n  }, [toggle, drop, show, alignEnd, menuElement, toggleElement, setMenu, setToggle]);\n\n  if (menuElement && lastShow && !show) {\n    focusInDropdown.current = menuElement.contains(document.activeElement);\n  }\n\n  var focusToggle = useEventCallback(function () {\n    if (toggleElement && toggleElement.focus) {\n      toggleElement.focus();\n    }\n  });\n  var maybeFocusFirst = useEventCallback(function () {\n    var type = lastSourceEvent.current;\n    var focusType = focusFirstItemOnShow;\n\n    if (focusType == null) {\n      focusType = menuRef.current && matches(menuRef.current, '[role=menu]') ? 'keyboard' : false;\n    }\n\n    if (focusType === false || focusType === 'keyboard' && !/^key.+$/.test(type)) {\n      return;\n    }\n\n    var first = qsa(menuRef.current, itemSelector)[0];\n    if (first && first.focus) first.focus();\n  });\n  useEffect(function () {\n    if (show) maybeFocusFirst();else if (focusInDropdown.current) {\n      focusInDropdown.current = false;\n      focusToggle();\n    } // only `show` should be changing\n  }, [show, focusInDropdown, focusToggle, maybeFocusFirst]);\n  useEffect(function () {\n    lastSourceEvent.current = null;\n  });\n\n  var getNextFocusedChild = function getNextFocusedChild(current, offset) {\n    if (!menuRef.current) return null;\n    var items = qsa(menuRef.current, itemSelector);\n    var index = items.indexOf(current) + offset;\n    index = Math.max(0, Math.min(index, items.length));\n    return items[index];\n  };\n\n  useGlobalListener('keydown', function (event) {\n    var _menuRef$current, _toggleRef$current;\n\n    var key = event.key;\n    var target = event.target;\n    var fromMenu = (_menuRef$current = menuRef.current) == null ? void 0 : _menuRef$current.contains(target);\n    var fromToggle = (_toggleRef$current = toggleRef.current) == null ? void 0 : _toggleRef$current.contains(target); // Second only to https://github.com/twbs/bootstrap/blob/8cfbf6933b8a0146ac3fbc369f19e520bd1ebdac/js/src/dropdown.js#L400\n    // in inscrutability\n\n    var isInput = /input|textarea/i.test(target.tagName);\n\n    if (isInput && (key === ' ' || key !== 'Escape' && fromMenu)) {\n      return;\n    }\n\n    if (!fromMenu && !fromToggle) {\n      return;\n    }\n\n    if (!menuRef.current && key === 'Tab') {\n      return;\n    }\n\n    lastSourceEvent.current = event.type;\n\n    switch (key) {\n      case 'ArrowUp':\n        {\n          var next = getNextFocusedChild(target, -1);\n          if (next && next.focus) next.focus();\n          event.preventDefault();\n          return;\n        }\n\n      case 'ArrowDown':\n        event.preventDefault();\n\n        if (!show) {\n          onToggle(true, event);\n        } else {\n          var _next = getNextFocusedChild(target, 1);\n\n          if (_next && _next.focus) _next.focus();\n        }\n\n        return;\n\n      case 'Tab':\n        // on keydown the target is the element being tabbed FROM, we need that\n        // to know if this event is relevant to this dropdown (e.g. in this menu).\n        // On `keyup` the target is the element being tagged TO which we use to check\n        // if focus has left the menu\n        addEventListener(document, 'keyup', function (e) {\n          var _menuRef$current2;\n\n          if (e.key === 'Tab' && !e.target || !((_menuRef$current2 = menuRef.current) != null && _menuRef$current2.contains(e.target))) {\n            onToggle(false, event);\n          }\n        }, {\n          once: true\n        });\n        break;\n\n      case 'Escape':\n        event.preventDefault();\n        event.stopPropagation();\n        onToggle(false, event);\n        break;\n\n      default:\n    }\n  });\n  return /*#__PURE__*/React.createElement(DropdownContext.Provider, {\n    value: context\n  }, children);\n}\n\nDropdown.displayName = 'ReactOverlaysDropdown';\nDropdown.propTypes = propTypes;\nDropdown.Menu = DropdownMenu;\nDropdown.Toggle = DropdownToggle;\nexport default Dropdown;"],"mappings":"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"},"metadata":{},"sourceType":"module"}