{"ast":null,"code":"export const getDisplayDate = (utils, rawValue, inputFormat) => {\n  const date = utils.date(rawValue);\n  const isEmpty = rawValue === null;\n\n  if (isEmpty) {\n    return '';\n  }\n\n  return utils.isValid(date) ? utils.formatByString( // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  date, inputFormat) : '';\n};\nconst MASK_USER_INPUT_SYMBOL = '_';\nconst staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';\nconst staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';\nexport function getMaskFromCurrentFormat(mask, format, acceptRegex, utils) {\n  if (mask) {\n    return mask;\n  }\n\n  const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n\n  if (inferredFormatPatternWith1Digits === inferredFormatPatternWith2Digits) {\n    return inferredFormatPatternWith1Digits;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.warn([`Mask does not support numbers with variable length such as 'M'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n  }\n\n  return '';\n}\nexport function checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {\n  if (!mask) {\n    return false;\n  }\n\n  const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n  const isMaskValid = inferredFormatPatternWith2Digits === inferredFormatPatternWith1Digits && mask === inferredFormatPatternWith2Digits;\n\n  if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {\n    if (format.includes('MMM')) {\n      console.warn([`Mask does not support literals such as 'MMM'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n    } else if (inferredFormatPatternWith2Digits && inferredFormatPatternWith2Digits !== inferredFormatPatternWith1Digits) {\n      console.warn([`Mask does not support numbers with variable length such as 'M'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n    } else if (mask) {\n      console.warn([`The mask \"${mask}\" you passed is not valid for the format used ${format}.`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n    }\n  }\n\n  return isMaskValid;\n}\nexport const maskedDateFormatter = (mask, acceptRegexp) => value => {\n  let outputCharIndex = 0;\n  return value.split('').map((char, inputCharIndex) => {\n    acceptRegexp.lastIndex = 0;\n\n    if (outputCharIndex > mask.length - 1) {\n      return '';\n    }\n\n    const maskChar = mask[outputCharIndex];\n    const nextMaskChar = mask[outputCharIndex + 1];\n    const acceptedChar = acceptRegexp.test(char) ? char : '';\n    const formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;\n    outputCharIndex += formattedChar.length;\n    const isLastCharacter = inputCharIndex === value.length - 1;\n\n    if (isLastCharacter && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {\n      // when cursor at the end of mask part (e.g. month) prerender next symbol \"21\" -> \"21/\"\n      return formattedChar ? formattedChar + nextMaskChar : '';\n    }\n\n    return formattedChar;\n  }).join('');\n};","map":{"version":3,"names":["getDisplayDate","utils","rawValue","inputFormat","date","isEmpty","isValid","formatByString","MASK_USER_INPUT_SYMBOL","staticDateWith2DigitTokens","staticDateWith1DigitTokens","getMaskFromCurrentFormat","mask","format","acceptRegex","formattedDateWith1Digit","inferredFormatPatternWith1Digits","replace","inferredFormatPatternWith2Digits","process","env","NODE_ENV","console","warn","join","checkMaskIsValidForCurrentFormat","isMaskValid","lib","includes","maskedDateFormatter","acceptRegexp","value","outputCharIndex","split","map","char","inputCharIndex","lastIndex","length","maskChar","nextMaskChar","acceptedChar","test","formattedChar","isLastCharacter"],"sources":["/Users/vbondarets/Desktop/CHRONOS/clients/node_modules/@mui/x-date-pickers/internals/utils/text-field-helper.js"],"sourcesContent":["export const getDisplayDate = (utils, rawValue, inputFormat) => {\n  const date = utils.date(rawValue);\n  const isEmpty = rawValue === null;\n\n  if (isEmpty) {\n    return '';\n  }\n\n  return utils.isValid(date) ? utils.formatByString( // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  date, inputFormat) : '';\n};\nconst MASK_USER_INPUT_SYMBOL = '_';\nconst staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';\nconst staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';\nexport function getMaskFromCurrentFormat(mask, format, acceptRegex, utils) {\n  if (mask) {\n    return mask;\n  }\n\n  const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n\n  if (inferredFormatPatternWith1Digits === inferredFormatPatternWith2Digits) {\n    return inferredFormatPatternWith1Digits;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.warn([`Mask does not support numbers with variable length such as 'M'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n  }\n\n  return '';\n}\nexport function checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {\n  if (!mask) {\n    return false;\n  }\n\n  const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n  const isMaskValid = inferredFormatPatternWith2Digits === inferredFormatPatternWith1Digits && mask === inferredFormatPatternWith2Digits;\n\n  if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {\n    if (format.includes('MMM')) {\n      console.warn([`Mask does not support literals such as 'MMM'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n    } else if (inferredFormatPatternWith2Digits && inferredFormatPatternWith2Digits !== inferredFormatPatternWith1Digits) {\n      console.warn([`Mask does not support numbers with variable length such as 'M'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n    } else if (mask) {\n      console.warn([`The mask \"${mask}\" you passed is not valid for the format used ${format}.`, `Falling down to uncontrolled no-mask input.`].join('\\n'));\n    }\n  }\n\n  return isMaskValid;\n}\nexport const maskedDateFormatter = (mask, acceptRegexp) => value => {\n  let outputCharIndex = 0;\n  return value.split('').map((char, inputCharIndex) => {\n    acceptRegexp.lastIndex = 0;\n\n    if (outputCharIndex > mask.length - 1) {\n      return '';\n    }\n\n    const maskChar = mask[outputCharIndex];\n    const nextMaskChar = mask[outputCharIndex + 1];\n    const acceptedChar = acceptRegexp.test(char) ? char : '';\n    const formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;\n    outputCharIndex += formattedChar.length;\n    const isLastCharacter = inputCharIndex === value.length - 1;\n\n    if (isLastCharacter && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {\n      // when cursor at the end of mask part (e.g. month) prerender next symbol \"21\" -> \"21/\"\n      return formattedChar ? formattedChar + nextMaskChar : '';\n    }\n\n    return formattedChar;\n  }).join('');\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}